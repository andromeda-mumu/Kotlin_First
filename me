1.inline 内联类，其实就是装箱操作，不是一个类型。其实就是穿了个马甲
2. object{}  这是一个匿名对象
3.object Named{} 是一个对象
4.companion object Factory{} 伴生对象是写在类内部的对象，在需要的地方，可以直接用类来引用。如果伴生对象是匿名的，则可以使用 类名.companion 来指代这个匿名对象
5.by 委托。在类声明的时候，可以不用完全复写接口的成员方法，交给委托的那个类就可以了。
6.by Delegate，by后面跟着一个类，当把属性委托给另一个类实现时，会调用Delegate类中的getValue,和setValue
7.延时属性，by lazy{} 其实和上面说的委托一样，交给lazy类里的lambda来实现的。
8.infix 中缀表达式，优先级低于算术运算，高于布尔运算。
9.inline 内联函数，是解决 高阶函数和闭包函数带来的开销问题。
    - 转成字节码后，可以看到，减去了入栈出栈。
    - 内联函数中，return可以写，支持非局部返回
10.inline 与 reified 一起使用.
    -reified 具体化类型参数
    -noinlined 在内联函数内部的lambda表达式，其形参也是inline的，为了使函数参数被其他非内联函数使用，则需要使用noinline这个标记，就把这个形参恢复正常了。
11.crossinline 非局部返回标记。为了不让内联函数的lamda表达式返回，直接写return是错的，需要写return@flag

-----------集合------
1.generateSequence(3) 这是无限的序列，从3开始的数组成集合。
2.zip 双集合 合并。[(green,flower),...]
3.unzip 可以将map这样的键值表，拆分成key集合，与value集合.
4.associateWith 与 associateBy，这两个函数可以将集合进行各种处理。
5.flatten 将嵌套的多个集合，融为一个整的集合。
6.joinToString 将集合转成字符串，其实就是没有中括号了。
    - 参数。将集合根据参数来得到需要的格式的字符串。
7.chunked，将一个集合分解成多个集合。
8.elementAtOrElse(index) 当越界时，返回lambda表达式内容。否则就返回index对应的值。


-------------协程-------------
1.通过withContext()来改变协程的上下文。其实就是改变线程的ThreadName
2.

